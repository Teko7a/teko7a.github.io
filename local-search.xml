<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>cf-edu128</title>
    <link href="/cf/e128/"/>
    <url>/cf/e128/</url>
    
    <content type="html"><![CDATA[<h1 id="a.-minimums-and-maximums">A. Minimums and Maximums</h1><h2 id="题意">题意</h2><p>一个包含 <span class="math inline">\(l_1 \sim r_1\)</span>个最小值，<span class="math inline">\(l_2 \sim r_2\)</span>个最大值的数组最短是多少？</p><h2 id="解答">解答</h2><p>令 <span class="math inline">\(l_1 \le l_2\)</span>，若 <spanclass="math inline">\(l_2 \in [l_1,r_1]\)</span>，则可以全设置为一种数值，数量为 <spanclass="math inline">\(l_2\)</span>。否则为 <spanclass="math inline">\(l_1 + l_2\)</span> 个数。</p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-type">int</span> a, b, c, d;  std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;  <span class="hljs-keyword">if</span> (a &gt; c) &#123;    std::<span class="hljs-built_in">tie</span>(a, b, c, d) = std::tuple&#123;c, d, a, b&#125;;  &#125;    std::cout &lt;&lt; c + a * (c != std::<span class="hljs-built_in">clamp</span>(c, a, b)) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcal O(1)\)</span></p></blockquote><h1 id="b.-robots">B. Robots</h1><h2 id="题意-1">题意</h2><p>二维地图上有一些棋子，他们的移动步伐一致，问是否可能在任何棋子都不越界情况下将某个棋子移动至<span class="math inline">\((0, 0)\)</span>。</p><h2 id="解答-1">解答</h2><p>想象成把终点移动至某个棋子。</p><p>要求即终点的横、纵两维同时切割到一个棋子。</p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0X3F3F3F3F</span>;  <span class="hljs-type">int</span> n, m, x = inf, y = inf;  std::cin &gt;&gt; n &gt;&gt; m;   <span class="hljs-keyword">auto</span> grids = <span class="hljs-built_in">multivector</span>&lt;<span class="hljs-type">char</span>&gt;(n, m, <span class="hljs-number">0</span>);  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;      std::cin &gt;&gt; grids[i][j];      <span class="hljs-keyword">if</span> (grids[i][j] == <span class="hljs-string">&#x27;R&#x27;</span>) &#123;        x = std::<span class="hljs-built_in">min</span>(x, i);        y = std::<span class="hljs-built_in">min</span>(y, j);      &#125;    &#125;  &#125;   std::cout &lt;&lt; (grids[x][y] == <span class="hljs-string">&#x27;R&#x27;</span> ? <span class="hljs-string">&quot;YES\n&quot;</span> : <span class="hljs-string">&quot;NO\n&quot;</span>);&#125;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcal O(n \timesm)\)</span>。</p></blockquote><blockquote><p>由于题目保证至少有一个棋子，因而访问到的空间都是合理的。</p></blockquote><h1 id="c.-binary-string">C. Binary String</h1><h2 id="题意-2">题意</h2><p>希望 <span class="math inline">\(\max\{\)</span> 剩下的 <spanclass="math inline">\(0\)</span>，删去的 <spanclass="math inline">\(1\)</span> <span class="math inline">\(\}\)</span>尽可能 <strong>小</strong>。</p><p>为此，你可以从两端删去任意多的字符，求此值。</p><h2 id="解答-2">解答</h2><p>从开头和结尾删去一些字符，实际上就是找到一个子区间。若固定区间的任一端点，另一端的变化是单调的。</p><p>双指针枚举，在 <span class="math inline">\(cnt_0 \lt cnt_1\)</span>情况（保证单调性）下一直右移右端点。右端点右移时，<spanclass="math inline">\(0\)</span> 可能变多，（从右侧）删去的 <spanclass="math inline">\(1\)</span>可能减少；而左端点右移时，（从左侧）删去的 <spanclass="math inline">\(1\)</span> 可能增多，留下的 <spanclass="math inline">\(0\)</span> 可能减少。</p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;  std::string s;  std::cin &gt;&gt; s;  <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();  <span class="hljs-type">int</span> o = std::<span class="hljs-built_in">count</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>(), <span class="hljs-string">&#x27;1&#x27;</span>);  <span class="hljs-type">int</span> a = o;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">-1</span>, z = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;    <span class="hljs-keyword">while</span> (j &lt; n - <span class="hljs-number">1</span> &amp;&amp; z &lt; o) &#123;      j += <span class="hljs-number">1</span>;      z += s[j] == <span class="hljs-string">&#x27;0&#x27;</span>;      o -= s[j] != <span class="hljs-string">&#x27;0&#x27;</span>;    &#125;    a = std::<span class="hljs-built_in">min</span>(a, std::<span class="hljs-built_in">max</span>(z, o));    z -= s[i] == <span class="hljs-string">&#x27;0&#x27;</span>;    o += s[i] != <span class="hljs-string">&#x27;0&#x27;</span>;  &#125;  std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcal O(n)\)</span></p><p>两者至多也只会各自遍历一次数组，因而为线性时间。</p></blockquote><h1 id="d.-dog-walking">D. Dog Walking</h1><h2 id="题意-3">题意</h2><p>&lt;++&gt;</p><h2 id="解答-3">解答</h2><p>&lt;++&gt;</p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp">&lt;++&gt;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcalO(&lt;++&gt;)\)</span></p></blockquote><h1 id="section">&lt;++&gt;</h1><h2 id="题意-4">题意</h2><p>&lt;++&gt;</p><h2 id="解答-4">解答</h2><p>&lt;++&gt;</p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp">&lt;++&gt;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcalO(&lt;++&gt;)\)</span></p></blockquote><h1 id="section-1">&lt;++&gt;</h1><h2 id="题意-5">题意</h2><p>&lt;++&gt;</p><h2 id="解答-5">解答</h2><p>&lt;++&gt;</p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp">&lt;++&gt;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcalO(&lt;++&gt;)\)</span></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>cf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>todo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cf788</title>
    <link href="/cf/788/"/>
    <url>/cf/788/</url>
    
    <content type="html"><![CDATA[<p class="note note-danger">这场学弟上蓝了，很是羡慕。希望自己能加油！</p><p><ahref="https://codeforces.com/contest/1670">https://codeforces.com/contest/1670</a></p><h1 id="a.-prof.-slim">A. Prof. Slim</h1><h2 id="题意">题意</h2><p>给定一些数，可多次选择两个符号不同的数字并交换他们的符号，这样操作能否使数组变为非严格上升的？</p><ul><li>保证均不为 <span class="math inline">\(0\)</span></li></ul><h2 id="解答">解答</h2><p>首先需要特判本来就有序。</p><p>否则（如果同时存在正负数）我们总能将负号集中在前面，正号放在后面，随后判断是否非严格上升即可。</p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-type">int</span> n;  std::cin &gt;&gt; n;  <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;  <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i : a) &#123;    std::cin &gt;&gt; i;    cnt += i &lt; <span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">is_sorted</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), std::less&lt;&gt;())) &#123;    <span class="hljs-keyword">return</span> std::cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>, <span class="hljs-built_in">void</span>();  &#125;  std::<span class="hljs-built_in">transform</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), a.<span class="hljs-built_in">begin</span>(), [&amp;](<span class="hljs-type">int</span> n) &#123; <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">abs</span>(n); &#125;);  std::<span class="hljs-built_in">transform</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">begin</span>() + cnt, a.<span class="hljs-built_in">begin</span>(), std::negate&lt;&gt;());  <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">is_sorted</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), std::less&lt;&gt;())) &#123;    std::cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;  &#125; <span class="hljs-keyword">else</span> &#123;    std::cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;  &#125;&#125;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcal O(n)\)</span></p></blockquote><h1 id="b.-dorms-war">B. Dorms War</h1><h2 id="题意-1">题意</h2><p>给定字符串 <span class="math inline">\(s\)</span> 以及 <spanclass="math inline">\(k\)</span>个特殊字符。可多次：删除特殊字符前面的字符, 直到不能删除为止。</p><p>问能操作多少次？</p><p class="note note-info">一个例子</p><blockquote><p><span class="math inline">\(s = ``joobeel&quot;, S = \{``o&quot;,``e&quot;\}\)</span></p><p><spanclass="math inline">\(``\color{red}{jo}\color{black}{o}\color{red}{be}\color{black}{el}&quot;\rightarrow ``\color{red}{o}\color{black}{el}&quot; \rightarrow``el&quot;\)</span></p></blockquote><h2 id="解答-1">解答</h2><p>不能操作，当且仅当特殊字符是第一个字符且是唯一一个特殊字符。</p><p>我们注意到，这个操作是贪心的，不是删除前面的所有字符（前面没有特殊字符时）就是删除到前面的特殊字符。</p><p>于是整个操作将会执行 <span class="math inline">\(\max\left\{p_{i} -p_{i - 1}\right\}\)</span> 次，即特殊字符间的最大间隔。</p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-type">int</span> n;  std::string s;  std::cin &gt;&gt; n &gt;&gt; s;  <span class="hljs-type">int</span> k;  std::cin &gt;&gt; k;  std::set&lt;<span class="hljs-type">int</span>&gt; S;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;    <span class="hljs-type">char</span> ch;    std::cin &gt;&gt; ch;    S.<span class="hljs-built_in">insert</span>(ch);  &#125;  <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, l = <span class="hljs-number">-1</span>, r = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;    <span class="hljs-keyword">if</span> (S.<span class="hljs-built_in">count</span>(s[i])) &#123;      std::<span class="hljs-built_in">tie</span>(l, r) = std::tuple&#123;r, i&#125;;      ans = std::<span class="hljs-built_in">max</span>(ans, r - l);    &#125;  &#125;  std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcal O(n \logn)\)</span></p></blockquote><p>Bonus: 直接记录所有位置即可。</p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-type">int</span> n;  std::string s;  std::cin &gt;&gt; n &gt;&gt; s;  <span class="hljs-type">int</span> k;  std::cin &gt;&gt; k;  std::bitset&lt;26&gt; S;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;    <span class="hljs-type">char</span> ch;    std::cin &gt;&gt; ch;    S[ch - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-literal">true</span>;  &#125;  <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, l = <span class="hljs-number">-1</span>, r = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;    <span class="hljs-keyword">if</span> (S.<span class="hljs-built_in">test</span>(s[i] - <span class="hljs-string">&#x27;a&#x27;</span>)) &#123;      std::<span class="hljs-built_in">tie</span>(l, r) = std::tuple&#123;r, i&#125;;      ans = std::<span class="hljs-built_in">max</span>(ans, r - l);    &#125;  &#125;  std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcal O(n)\)</span></p></blockquote><h1 id="c.-where-is-the-pizza">C. Where is the Pizza?</h1><h2 id="题意-2">题意</h2><p>给定两个排列 <span class="math inline">\(\{A\}\{B\}\)</span>，以及一个序列 <spanclass="math inline">\(\{D\}\)</span>。</p><p>生成一个排列 <span class="math inline">\(\{C\}\)</span>，满足如果<span class="math inline">\(D_i \ne 0\)</span> ，那么 <spanclass="math inline">\(C_i = D_i\)</span>; 否则 <spanclass="math inline">\(C_i \in \{A_i, B_i\}\)</span>。</p><p><span class="math inline">\(\{C\}\)</span> 有多少种可能？</p><h2 id="解答-2">解答</h2><p>连接 <span class="math inline">\(A_i \rightarrowB_i\)</span>，因为是排列，所以总能形成若干联通块。</p><p>每一个联通块，同时必定也是环。对于每一个环，若有一个元素确定，那么整个环在<span class="math inline">\(\cal \{C\}\)</span> 中也是确定的。</p><p>否则每个元素只有两种可能 <span class="math inline">\(A_i\mathtt{\;or\;} B_i\)</span>。每个环都是独立的，因此答案为 <spanclass="math inline">\(2 ^ {t}\)</span>，其中 <spanclass="math inline">\(t\)</span> 为环个数。</p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1&#x27;000&#x27;000&#x27;007</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-type">int</span> n;  std::cin &gt;&gt; n;  <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span>, <span class="hljs-title">b</span><span class="hljs-params">(n)</span>, <span class="hljs-title">p</span><span class="hljs-params">(n)</span></span>;  <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n)</span></span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i : a) &#123;    std::cin &gt;&gt; i;    i -= <span class="hljs-number">1</span>;  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i : b) &#123;    std::cin &gt;&gt; i;    i -= <span class="hljs-number">1</span>;  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, d; i &lt; n; ++i) &#123;    std::cin &gt;&gt; d;    <span class="hljs-keyword">if</span> (d != <span class="hljs-number">0</span>) &#123;      visited[a[i]] = visited[b[i]] = <span class="hljs-literal">true</span>;    &#125;  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;    p[a[i]] = b[i];  &#125;  <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">st</span><span class="hljs-params">(n)</span></span>;  <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;    <span class="hljs-keyword">if</span> (!st[i]) &#123;      <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>, flag = <span class="hljs-number">0</span>;      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; !st[j]; j = p[j]) &#123;        st[j] = <span class="hljs-literal">true</span>;        cnt += <span class="hljs-number">1</span>;        flag |= visited[j];      &#125;      <span class="hljs-keyword">if</span> (cnt != <span class="hljs-number">1</span> &amp;&amp; flag == <span class="hljs-literal">false</span>) &#123;        ans = <span class="hljs-number">2ll</span> * ans % mod;      &#125;    &#125;  &#125;  std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcal O(n)\)</span></p></blockquote><p>Bonus: 实际上是数点数大于 <span class="math inline">\(2\)</span>并且没有被标记的联通块，使用并查集即可。</p><details><summary>展开代码</summary><p><img src="/images/cf/cf788c.png" srcset="/img/loading.gif" lazyload /></p></details><blockquote><p>复杂度： <span class="math inline">\(\mathcal O(n \alpha(n))\)</span></p></blockquote><p class="note note-primary">Bonus2:<a href="https://atcoder.jp/contests/abc247/tasks/abc247_f">https://atcoder.jp/contests/abc247/tasks/abc247_f</a></p><h1 id="d.-very-suspicious">D. Very Suspicious</h1><h2 id="题意-3">题意</h2><p>在一个无限大的由六边形的平面上用直线（必须与六边形的某条边平行）分割出等边三角形,问要分割出<span class="math inline">\(n\)</span>个等边三角形至少需要多少条直线。</p><p><img src="/images/cf/cf788d.png" srcset="/img/loading.gif" lazyload /></p><h2 id="解答-3">解答</h2><p>设三种方向的线分别有 <span class="math inline">\(x, y, z\)</span>条，容易发现他们会交出 <span class="math inline">\((xy + yz +xz)\)</span>个点，这些点与六边形本来的边构成一系列（成对出现）等边三角形。</p><p><img src="/images/cf/cf788d2.png" srcset="/img/loading.gif" lazyload /></p><p>我们熟知</p><p><span class="math display">\[2 (xy + yz + xz) \le 2 (x ^ 2 + y ^ 2 + z ^ 2) \quad (``=&quot;\mathrm{\;iff.\;} x = y = z)\]</span></p><p>现在有 <span class="math inline">\(x + y + z = n\)</span>, 均分出<spanclass="math inline">\(\left\langle\left\lfloor\dfrac{n}{3}\right\rfloor,\left\lfloor\dfrac{n+ 1}{3}\right\rfloor,\left\lceil\dfrac{n}{3}\right\rceil\right\rangle\)</span> 即可。</p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> tt;<span class="hljs-keyword">for</span> (std::cin &gt;&gt; tt; tt != <span class="hljs-number">0</span>; tt -= <span class="hljs-number">1</span>) &#123;  <span class="hljs-type">int</span> n;  std::cin &gt;&gt; n;  i64 l = <span class="hljs-number">0</span>, r = <span class="hljs-number">100&#x27;000</span>;  <span class="hljs-keyword">while</span> (l + <span class="hljs-number">1</span> &lt; r) &#123;    i64 mid = (l + r) / <span class="hljs-number">2</span>;    i64 x = mid / <span class="hljs-number">3</span>, y = (mid + <span class="hljs-number">1</span>) / <span class="hljs-number">3</span>, z = (mid + <span class="hljs-number">2</span>) / <span class="hljs-number">3</span>;    <span class="hljs-keyword">if</span> (<span class="hljs-number">2LL</span> * (x * y + y * z + x * z) &gt;= n) &#123;      r = mid;    &#125; <span class="hljs-keyword">else</span> &#123;      l = mid;    &#125;  &#125;  std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcal O(T \logn)\)</span></p></blockquote><p class="note note-info">Bonus: <a href="http://oeis.org/A030511">http://oeis.org/A030511</a></p><details><summary>展开</summary><p><span class="math display">\[\begin{cases}a(n) = \dfrac{2 \times (n - 1)^2}{3} &amp; if\; n \equiv 1 \pmod 3\\\\a(n) = \dfrac{2 \times n \times (n - 2)}{3} &amp; \rmotherwise.\end{cases}\]</span></p></details><h1 id="e.-hemose-on-the-tree">E. Hemose on the Tree</h1><h2 id="题意-4">题意</h2><p>给定一棵 <span class="math inline">\(2 ^ p\)</span>个节点的树，给其点、边标注 <span class="math inline">\([1, 2n -1]\)</span> 的权，随后选择一个根。</p><p>使得根到其他点经过的点、边权之异或和的最大值最小。</p><h2 id="解答-4">解答</h2><p>最高位是 <span class="math inline">\(p\)</span>，注意到整个值域关于<span class="math inline">\(n\)</span> 对称，一个自然的想法是 <spanclass="math inline">\(n \mathtt{\;xor\;} t \mathtt{\;xor\;} n + t =0\)</span>。</p><p>即以 <span class="math inline">\(n\)</span>为根，其他的数对称放置在点与边上即可, 这样就能使得权重或 <spanclass="math inline">\(0\)</span> 或 <spanclass="math inline">\(n\)</span>, 分层构造之。</p><p>同时，因为先经过边，所以边上要放大的数抵消掉最高位，到下一层再反转过来就行了。</p><hr /><p>有没有更好的解呢？答案是否定的。</p><p>取 <span class="math inline">\(t \;(t \lt n)\)</span>做根，要使得异或出来的数字也是 <span class="math inline">\(\ltn\)</span> 的，那么接下来每条边、每个点都需要是 <spanclass="math inline">\(\lt n\)</span> 的，这显然不行。</p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-type">int</span> p;  std::cin &gt;&gt; p;  <span class="hljs-type">int</span> n = <span class="hljs-number">1</span> &lt;&lt; p;  std::vector&lt;std::vector&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">G</span>(n);  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, u, v; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;    std::cin &gt;&gt; u &gt;&gt; v;    u -= <span class="hljs-number">1</span>, v -= <span class="hljs-number">1</span>;    G[u].<span class="hljs-built_in">emplace_back</span>(v, i);    G[v].<span class="hljs-built_in">emplace_back</span>(u, i);  &#125;  <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span>, <span class="hljs-title">b</span><span class="hljs-params">(n - <span class="hljs-number">1</span>)</span></span>;  a[<span class="hljs-number">0</span>] = n;  <span class="hljs-keyword">auto</span> dfs = [&amp;](<span class="hljs-keyword">auto</span> &amp;&amp;self, <span class="hljs-type">int</span> u, <span class="hljs-type">int</span> p, <span class="hljs-type">bool</span> v) -&gt; <span class="hljs-type">void</span> &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;[to, j] : G[u]) <span class="hljs-keyword">if</span> (to != p) &#123;      <span class="hljs-keyword">if</span> (v) &#123;        std::<span class="hljs-built_in">tie</span>(b[j], a[to]) = std::tuple&#123;to ^ n, to&#125;;      &#125; <span class="hljs-keyword">else</span> &#123;        std::<span class="hljs-built_in">tie</span>(b[j], a[to]) = std::tuple&#123;to, to ^ n&#125;;      &#125;      <span class="hljs-built_in">self</span>(self, to, u, v ^ <span class="hljs-number">1</span>);    &#125;  &#125;;  <span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>);  std::cout &lt;&lt; <span class="hljs-string">&quot;1\n&quot;</span>;  std::<span class="hljs-built_in">copy</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), std::<span class="hljs-built_in">ostream_iterator</span>&lt;<span class="hljs-type">int</span>&gt;(std::cout, <span class="hljs-string">&quot; &quot;</span>));  std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;  std::<span class="hljs-built_in">copy</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>(), std::<span class="hljs-built_in">ostream_iterator</span>&lt;<span class="hljs-type">int</span>&gt;(std::cout, <span class="hljs-string">&quot; &quot;</span>));  std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcal O(n = 2 ^p)\)</span></p></blockquote><h1 id="f.-jee-you-see">* F. Jee, You See?</h1><h2 id="题意-5">题意</h2><p>给定 <span class="math inline">\(n, l, r, z\)</span>，问有多少长度为<span class="math inline">\(n\)</span> 的序列 <spanclass="math inline">\(s\)</span> 满足：</p><ul><li><span class="math inline">\(\displaystyle\sum_{i = l}^r{s[i]} \in[l, r]\)</span></li><li><span class="math inline">\(\displaystyle\bigoplus_{i = l}^r{s[i]} =z\)</span></li></ul><h2 id="解答-5">解答</h2><p>数位背包，待学。</p><p>&lt;++&gt;</p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;i64 l, r, z;std::cin &gt;&gt; n &gt;&gt; l &gt;&gt; r &gt;&gt; z;<span class="hljs-function">std::vector&lt;Z&gt; <span class="hljs-title">choose</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;choose[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;  choose[i] = choose[i - <span class="hljs-number">1</span>] * (n - i + <span class="hljs-number">1</span>) / i;&#125;<span class="hljs-keyword">auto</span> solve = [&amp;](i64 r) &#123;  std::vector&lt;Z&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>);  dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">59</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;    <span class="hljs-type">int</span> d = r &gt;&gt; i &amp; <span class="hljs-number">1</span>;    <span class="hljs-type">int</span> u = z &gt;&gt; i &amp; <span class="hljs-number">1</span>;    <span class="hljs-function">std::vector&lt;Z&gt; <span class="hljs-title">g</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; j++) &#123;      <span class="hljs-type">int</span> k = <span class="hljs-number">2</span> * j + d;      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = u; x &lt;= n &amp;&amp; x &lt;= k; x += <span class="hljs-number">2</span>) &#123;        <span class="hljs-type">int</span> l = std::<span class="hljs-built_in">min</span>(n, k - x);        g[l] += dp[j] * choose[x];      &#125;    &#125;    dp = g;  &#125;  <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">accumulate</span>(dp.<span class="hljs-built_in">begin</span>(), dp.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">Z</span>(<span class="hljs-number">0</span>));&#125;;std::cout &lt;&lt; (<span class="hljs-built_in">solve</span>(r) - <span class="hljs-built_in">solve</span>(l - <span class="hljs-number">1</span>)).<span class="hljs-built_in">val</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcal O(n ^ 2 \logn)\)</span></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>cf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>todo</tag>
      
      <tag>dp</tag>
      
      <tag>dsu</tag>
      
      <tag>oeis</tag>
      
      <tag>greedy</tag>
      
      <tag>找环</tag>
      
      <tag>二分</tag>
      
      <tag>构造</tag>
      
      <tag>位运算</tag>
      
      <tag>数位背包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cf787</title>
    <link href="/cf/787/"/>
    <url>/cf/787/</url>
    
    <content type="html"><![CDATA[<p><ahref="https://codeforces.com/contest/1675">https://codeforces.com/contest/1675</a></p><h1 id="a.-food-for-animals">A. Food for Animals</h1><h2 id="题意">题意</h2><p>给定 <span class="math inline">\(a\)</span> 个狗粮，<spanclass="math inline">\(b\)</span> 个猫粮，<spanclass="math inline">\(c\)</span> 个任意。是否能够给 <spanclass="math inline">\(x\)</span> 只狗、<spanclass="math inline">\(y\)</span> 只猫各自分配一个？</p><h2 id="解答">解答</h2><p>最后分配任意的。</p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-type">int</span> a, b, c, x, y;  std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; x &gt;&gt; y;  x = std::<span class="hljs-built_in">max</span>(x - a, <span class="hljs-number">0</span>);  y = std::<span class="hljs-built_in">max</span>(y - b, <span class="hljs-number">0</span>);  std::cout &lt;&lt; (x + y &gt; c ? <span class="hljs-string">&quot;NO\n&quot;</span> : <span class="hljs-string">&quot;YES\n&quot;</span>);&#125;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcal O(1)\)</span></p></blockquote><h1 id="b.-make-it-increasing">B. Make It Increasing</h1><h2 id="题意-1">题意</h2><p>给定数组，你可多次将某数 <strong>整除</strong> <spanclass="math inline">\(2\)</span>，问能否将其变为严格单调递增的序列？如果有，回答最小操作次数。</p><h2 id="解答-1">解答</h2><blockquote><p>事实证明，不能 xjb 想特判，不然会死得很惨。</p></blockquote><p>固定最后一个值不动，从后往前遍历即可。</p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-type">int</span> n;  std::cin &gt;&gt; n;  <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i : a) &#123;    std::cin &gt;&gt; i;  &#125;  <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;    <span class="hljs-keyword">if</span> (!a[i + <span class="hljs-number">1</span>]) &#123;      <span class="hljs-keyword">return</span> std::cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>, <span class="hljs-built_in">void</span>();    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">while</span> (a[i] &gt;= a[i + <span class="hljs-number">1</span>]) &#123;        a[i] &gt;&gt;= <span class="hljs-number">1</span>;        ans += <span class="hljs-number">1</span>;      &#125;    &#125;  &#125;  std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcal O(n \lg n)\)</span></p></blockquote><h1 id="c.-detective-task">C. Detective Task</h1><h2 id="题意-2">题意</h2><p>房间里放了一幅画，但是被贼了。小明询问他的朋友们<strong>是否看到了画</strong>，朋友们将回答 <spanclass="math inline">\(1 / 0 / ?\)</span> 表示肯定与否、记不清了。</p><p>房间里某时刻仅有一个人，询问次序为离开次序。问有多少人可疑？</p><h2 id="解答-2">解答</h2><p><span class="math inline">\(0 \star 1\)</span>出现时，可以断定一定有人说谎，因此答案为首个 <spanclass="math inline">\(0\)</span> 和最后一个 <spanclass="math inline">\(1\)</span> 的距离。</p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;  std::string s;  std::cin &gt;&gt; s;  <span class="hljs-type">int</span> p1 = <span class="hljs-number">0</span>, p0 = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-type">int</span>) s.<span class="hljs-built_in">size</span>(); ++i) &#123;    <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;      p0 = i;      <span class="hljs-keyword">break</span>;    &#125;  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = (<span class="hljs-type">int</span>) s.<span class="hljs-built_in">size</span>(); i &gt;= <span class="hljs-number">0</span>; --i) &#123;    <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;      p1 = i;      <span class="hljs-keyword">break</span>;    &#125;  &#125;  std::cout &lt;&lt; std::<span class="hljs-built_in">abs</span>(p0 - p1 + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcal O(n)\)</span></p></blockquote><h1 id="d.-vertical-paths">D. Vertical Paths</h1><h2 id="题意-3">题意</h2><p>求最少的不交链将给定的树完全覆盖。</p><h2 id="解答-3">解答</h2><p>显然叶子个数即为所求。</p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-type">int</span> n;  std::cin &gt;&gt; n;  <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(n)</span></span>;  <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">leaf</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;    std::cin &gt;&gt; p[i];    p[i] -= <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span> (p[i] != i) &#123;      leaf[p[i]] = <span class="hljs-literal">false</span>;    &#125;  &#125;  std::cout &lt;&lt; std::<span class="hljs-built_in">count</span>(leaf.<span class="hljs-built_in">begin</span>(), leaf.<span class="hljs-built_in">end</span>(), <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;  <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n)</span></span>;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;    <span class="hljs-keyword">if</span> (leaf[i]) &#123;      std::stack&lt;<span class="hljs-type">int</span>&gt; ans;      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; !visited[j]; j = p[j]) &#123;        visited[j] = <span class="hljs-literal">true</span>;        ans.<span class="hljs-built_in">push</span>(j + <span class="hljs-number">1</span>);      &#125;      std::cout &lt;&lt; (<span class="hljs-type">int</span>) ans.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;      <span class="hljs-keyword">while</span> (ans.<span class="hljs-built_in">size</span>()) &#123;        std::cout &lt;&lt; ans.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[ans.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>];        ans.<span class="hljs-built_in">pop</span>();      &#125;    &#125;  &#125;  std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcal O(n)\)</span></p></blockquote><h1 id="e.-replace-with-the-previous-minimize">E. Replace With thePrevious, Minimize</h1><h2 id="题意-4">题意</h2><p>将出现的所有某字母 <span class="math inline">\(x\)</span> 都变为<span class="math inline">\(x - 1\)</span>。问这样对 <spanclass="math inline">\(s\)</span> 操作 <spanclass="math inline">\(k\)</span> 次之后，得到的最小字符串是什么？</p><h2 id="解答-4">解答</h2><p>在改变 <span class="math inline">\(c \rightarrow b \rightarrowa\)</span> 的过程中可以将 <span class="math inline">\(b, c\)</span>都变为 <spanclass="math inline">\(a\)</span>。因此我们只需要考虑怎么操作某一个较大的字符。</p><p>需要字典序最小，因此考虑从左至右枚举，找到第一个大于 <spanclass="math inline">\(k\)</span>的字符将其改小，小于该字符的实体都可变作 <spanclass="math inline">\(``a&quot;\)</span>。</p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-type">int</span> n, k;  std::string s;  std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; s;  <span class="hljs-type">int</span> M = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;    <span class="hljs-keyword">if</span> (s[i] - <span class="hljs-string">&#x27;a&#x27;</span> &gt; k) &#123;      <span class="hljs-type">int</span> l = s[i] - k + M, r = s[i];      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c : s) &#123;        <span class="hljs-keyword">if</span> (c &gt;= l &amp;&amp; c &lt;= r) &#123;          c = l;        &#125;      &#125;      <span class="hljs-keyword">break</span>;    &#125;    M = std::<span class="hljs-built_in">max</span>(M, s[i] - <span class="hljs-string">&#x27;a&#x27;</span>);  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i : s) &#123;    <span class="hljs-keyword">if</span> (i &lt;= <span class="hljs-string">&#x27;a&#x27;</span> + M) &#123;      i = <span class="hljs-string">&#x27;a&#x27;</span>;    &#125;  &#125;  std::cout &lt;&lt; s &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcal O(n)\)</span></p></blockquote><p>Bonus:将能同时变化的点连接起来，某个联通块内的字符都变为同一种字符。</p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-type">int</span> n, k;  std::string s;  std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; s;  <span class="hljs-function">DSU <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n &amp;&amp; k != <span class="hljs-number">0</span>; ++i) &#123;    <span class="hljs-type">int</span> p = g.<span class="hljs-built_in">find</span>(s[i] - <span class="hljs-string">&#x27;a&#x27;</span>);    <span class="hljs-keyword">if</span> (!p) &#123;      <span class="hljs-keyword">continue</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">while</span> (p != <span class="hljs-number">0</span> &amp;&amp; k != <span class="hljs-number">0</span>) &#123;        g.<span class="hljs-built_in">helper</span>(p, p - <span class="hljs-number">1</span>);        p = g.<span class="hljs-built_in">find</span>(p);        k -= <span class="hljs-number">1</span>;      &#125;    &#125;  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c : s) &#123;    c = <span class="hljs-string">&#x27;a&#x27;</span> + g.<span class="hljs-built_in">find</span>(c - <span class="hljs-string">&#x27;a&#x27;</span>);  &#125;  std::cout &lt;&lt; s &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcal O(n\alpha(n))\)</span></p></blockquote><h1 id="f.-vlad-and-unfinished-business">F. Vlad and UnfinishedBusiness</h1><h2 id="题意-5">题意</h2><p>求在树上从 <span class="math inline">\(x\)</span> 经过给定的 <spanclass="math inline">\(k\)</span> 个关键点到达 <spanclass="math inline">\(y\)</span> 的最小步数。</p><h2 id="解答-5">解答</h2><p>不妨以 <span class="math inline">\(x\)</span>为根，我们熟知树上两点的路是唯一的，因而要到达关键点的最优走法自然是遍历某子树的所有关键点，随后原路返回。</p><p>特殊的，<span class="math inline">\(y\)</span>不需要折返，最终减去其深度即可。</p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-type">int</span> n, k, x, y;  std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; x &gt;&gt; y;  x -= <span class="hljs-number">1</span>, y -= <span class="hljs-number">1</span>;  <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(k)</span></span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i : a) &#123;    std::cin &gt;&gt; i;    i -= <span class="hljs-number">1</span>;  &#125;  a.<span class="hljs-built_in">push_back</span>(y);  std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">G</span>(n);  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, u, v; i &lt; n; ++i) &#123;    std::cin &gt;&gt; u &gt;&gt; v;    u -= <span class="hljs-number">1</span>, v -= <span class="hljs-number">1</span>;    G[u].<span class="hljs-built_in">push_back</span>(v);    G[v].<span class="hljs-built_in">push_back</span>(u);  &#125;  <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dep</span><span class="hljs-params">(n)</span>, <span class="hljs-title">pre</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;  <span class="hljs-keyword">auto</span> dfs = [&amp;](<span class="hljs-keyword">auto</span> &amp;&amp;self, <span class="hljs-type">int</span> u) -&gt; <span class="hljs-type">void</span> &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;to : G[u]) <span class="hljs-keyword">if</span> (to != pre[u]) &#123;      pre[to] = u;      dep[to] = dep[u] + <span class="hljs-number">1</span>;      <span class="hljs-built_in">self</span>(self, to);    &#125;  &#125;;  <span class="hljs-built_in">dfs</span>(dfs, x);  <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;  <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n)</span></span>;  visited[x] = <span class="hljs-literal">true</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;p : a) &#123;    <span class="hljs-keyword">while</span> (!visited[p]) &#123;      visited[p] = <span class="hljs-literal">true</span>;      ans += <span class="hljs-number">2</span>;      p = pre[p];    &#125;  &#125;  ans -= dep[y];  std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcal O(n)\)</span></p></blockquote><h1 id="g.-sorting-pancakes">G. Sorting Pancakes</h1><h2 id="题意-6">题意</h2><p>给定一个和为 <span class="math inline">\(m\)</span>的数组，可多次选择俩相邻元素，一个加一另一个减一。</p><p>问最少操作多少此使得数组非严格递减？</p><ul><li><span class="math inline">\(m \le 250\)</span></li></ul><h2 id="解答-6">解答</h2><p>用 <span class="math inline">\(dp_{\{i, j, k\}}\)</span> 表示前 <spanclass="math inline">\(i\)</span> 个位置、<strong>当前和</strong> 为<span class="math inline">\(j\)</span>、最后一个数是 <spanclass="math inline">\(k\)</span> 的满足题意的答案。</p><p><span class="math display">\[dp_{\{i, j, k\}} = \min_{t \le k}dp_{\{i-1, j, t\}} + \left|\sum_{q = 1}^ {i + 1}a_q - (j + k)\right|\]</span></p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt; <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">chmin</span><span class="hljs-params">(T &amp;x, T y)</span> </span>&#123; x = x &lt; y ? x : y; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>)-&gt;<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);  <span class="hljs-type">int</span> n, m;  std::cin &gt;&gt; n &gt;&gt; m;  <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span>, <span class="hljs-title">s</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;    std::cin &gt;&gt; a[i];    s[i + <span class="hljs-number">1</span>] = s[i] + a[i];  &#125;  <span class="hljs-function">std::vector <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, std::vector(m + <span class="hljs-number">1</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>, <span class="hljs-number">0X7F7F7F7F</span>)))</span></span>;  dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][m] = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; ++j) &#123;      <span class="hljs-type">int</span> mx = <span class="hljs-number">0X7F7F7F7F</span>;      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = m; k &gt;= <span class="hljs-number">0</span>; --k) &#123;        <span class="hljs-built_in">chmin</span>(mx, dp[i][j][k]);        <span class="hljs-keyword">if</span> (j + k &lt;= m) &#123;          <span class="hljs-built_in">chmin</span>(dp[i + <span class="hljs-number">1</span>][j + k][k], mx + std::<span class="hljs-built_in">abs</span>(s[i + <span class="hljs-number">1</span>] - (j + k)));        &#125;      &#125;    &#125;  &#125;  std::cout &lt;&lt; *std::<span class="hljs-built_in">min_element</span>(dp[n][m].<span class="hljs-built_in">begin</span>(), dp[n][m].<span class="hljs-built_in">end</span>()) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ^ <span class="hljs-number">0</span>;&#125;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcal O(n m ^ 2)\)</span></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>cf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>dfs</tag>
      
      <tag>dsu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cf786</title>
    <link href="/cf/786/"/>
    <url>/cf/786/</url>
    
    <content type="html"><![CDATA[<p><ahref="https://codeforces.com/contest/1674">https://codeforces.com/contest/1674</a></p><h1 id="a.-number-transformation">A. Number Transformation</h1><h2 id="题意">题意</h2><p>给定 <span class="math inline">\(x, y\)</span>。试给出 <spanclass="math inline">\((a, b)\)</span> 表示通过对 <spanclass="math inline">\(x\)</span> 乘以 <span class="math inline">\(b ^a\)</span> 将 <span class="math inline">\(x\)</span> 转变为 <spanclass="math inline">\(y\)</span>，或回答不可能。</p><h2 id="解答">解答</h2><p><span class="math inline">\(x \le y \land x \mid y\)</span>时有解，<span class="math inline">\((1, \dfrac{y}{x})\)</span>是可满足的一组解。</p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-type">int</span> a, b;  std::cin &gt;&gt; a &gt;&gt; b;  <span class="hljs-keyword">if</span> (b % a != <span class="hljs-number">0</span> || b &lt; a) &#123;    <span class="hljs-keyword">return</span> std::cout &lt;&lt; <span class="hljs-string">&quot;0 0\n&quot;</span>, <span class="hljs-built_in">void</span>();  &#125;  std::cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; (b / a) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcal O(1)\)</span></p></blockquote><h1 id="b.-dictionary">B. Dictionary</h1><h2 id="题意-1">题意</h2><p>两个不同字母组成的集合中，给定的 <spanclass="math inline">\(s\)</span> 居于第几？</p><h2 id="解答-1">解答</h2><p>注意到 <span class="math inline">\(26 ^ 2 - 26 =650\)</span>，非常小。预处理出来这个集合也是可以接受的。</p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-type">static</span> <span class="hljs-type">bool</span> initialized = <span class="hljs-literal">false</span>;  <span class="hljs-type">static</span> std::map&lt;std::array&lt;<span class="hljs-type">char</span>, 2&gt;, <span class="hljs-type">int</span>&gt; mp;  <span class="hljs-keyword">if</span> (!initialized) &#123;    initialized ^= <span class="hljs-number">1</span>;    <span class="hljs-type">int</span> idx = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">26</span>; ++j) &#123;        <span class="hljs-keyword">if</span> (i == j) &#123;          <span class="hljs-keyword">continue</span>;        &#125; <span class="hljs-keyword">else</span> &#123;          std::array&lt;<span class="hljs-type">char</span>, <span class="hljs-number">2</span>&gt; c;          c[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;a&#x27;</span> + i;          c[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;a&#x27;</span> + j;          mp[c] = idx ++;        &#125;      &#125;    &#125;  &#125;  std::array&lt;<span class="hljs-type">char</span>, 2&gt; c;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;ch : c) &#123;    std::cin &gt;&gt; ch;  &#125;  std::cout &lt;&lt; mp[c] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcal O(|\Sigma| ^ 2 + T \log|\Sigma|)\)</span></p></blockquote><hr /><p>Bonus: 此集合实为 <span class="math inline">\(26\)</span>进制「抠掉」所有 <span class="math inline">\(a = b\)</span>的点。因此可以关于 <span class="math inline">\(a &lt;\!\!\!\!?\;\;b\)</span> 分类讨论。</p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-type">char</span> a, b;  std::cin &gt;&gt; a &gt;&gt; b;  a -= <span class="hljs-string">&#x27;a&#x27;</span>, b -= <span class="hljs-string">&#x27;a&#x27;</span>;  std::cout &lt;&lt; <span class="hljs-number">25</span> * a + b - (b &gt; a) + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcal O(1)\)</span></p></blockquote><h1 id="c.-infinite-replacement">C. Infinite Replacement</h1><h2 id="题意-2">题意</h2><p>给定两个字符串 <span class="math inline">\(s, t\)</span>，其中 <spanclass="math inline">\(s\)</span> <strong>全为</strong><code>a</code>。你可以多次将某个 <code>a</code> 替换为 <spanclass="math inline">\(t\)</span>，问有多少种可能的字符串？</p><p>或回答有无穷多种。</p><h2 id="解答-2">解答</h2><p>如果 <span class="math inline">\(t =``a&quot;\)</span>，那么总有最初的那一种。如果替换上去的部分依然包含<spanclass="math inline">\(``a&quot;\)</span>，那么有无穷多种可能。正如：</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;&#123;&#125;&#x27;</span>).<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;&#123;&#125;&#x27;</span>).<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;&#123;&#125;&#x27;</span>).<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;&#123;&#125;&#x27;</span>))</code></pre></div><p>否则（<span class="math inline">\(``a&quot; \notin t\)</span>）,原串中的每一个位置都可以选择换或者不换，于是方案数为 <spanclass="math inline">\(2 ^ n\)</span>。</p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;  std::string s, t;  std::cin &gt;&gt; s &gt;&gt; t;  <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">count</span>(t.<span class="hljs-built_in">begin</span>(), t.<span class="hljs-built_in">end</span>(), <span class="hljs-string">&#x27;a&#x27;</span>) != <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">if</span> (t == <span class="hljs-string">&quot;a&quot;</span>) &#123;      <span class="hljs-keyword">return</span> std::cout &lt;&lt; <span class="hljs-string">&quot;1\n&quot;</span>, <span class="hljs-built_in">void</span>();    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> std::cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>, <span class="hljs-built_in">void</span>();    &#125;  &#125;  std::cout &lt;&lt; (<span class="hljs-number">1LL</span> &lt;&lt; s.<span class="hljs-built_in">size</span>()) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcal O(|t|)\)</span></p></blockquote><h1 id="d.-a-b-c-sort">D. A-B-C Sort</h1><h2 id="题意-3">题意</h2><p>给定数组 <span class="math inline">\(\{A\}\)</span>，以及两个空数组<span class="math inline">\(\{B\},\{C\}\)</span>。执行下面的算法之后，<spanclass="math inline">\(\{C\}\)</span> 是否能变为单调不减的序列？</p><p><img src="/images/cf/cf786d.png" srcset="/img/loading.gif" lazyload /></p><details><summary>这一段的 LaTeX 代码</summary><div class="hljs code-wrapper"><pre><code class="hljs latex"><span class="hljs-keyword">\def</span><span class="hljs-keyword">\SetClass</span>&#123;article&#125;<span class="hljs-keyword">\documentclass</span>&#123;<span class="hljs-keyword">\SetClass</span>&#125;<span class="hljs-keyword">\usepackage</span>[lined,boxed,commentsnumbered]&#123;algorithm2e&#125;<span class="hljs-keyword">\begin</span>&#123;document&#125;<span class="hljs-keyword">\begin</span>&#123;algorithm&#125;[H]  <span class="hljs-keyword">\SetAlgoLined</span><span class="hljs-comment">%%  \KwData&#123; \&#123; A \&#125;&#125;</span><span class="hljs-comment">%%  \KwResult&#123;&#125;</span>  <span class="hljs-keyword">\While</span>&#123; <span class="hljs-keyword">\&#123;</span>A<span class="hljs-keyword">\&#125;</span> is not empty &#125;&#123;    <span class="hljs-keyword">\eIf</span>&#123; <span class="hljs-keyword">\&#123;</span>B<span class="hljs-keyword">\&#125;</span> is odd long &#125;&#123;      <span class="hljs-built_in">$</span>p <span class="hljs-keyword">\leftarrow</span><span class="hljs-built_in">$</span> B[middle - 1] or B[middle + 1]    &#125;&#123;      <span class="hljs-built_in">$</span>p <span class="hljs-keyword">\leftarrow</span><span class="hljs-built_in">$</span> B[middle]    &#125;    move last element of <span class="hljs-keyword">\&#123;</span>A<span class="hljs-keyword">\&#125;</span> to B<span class="hljs-built_in">$</span><span class="hljs-built_in">_</span>p<span class="hljs-built_in">$</span>  &#125;  <span class="hljs-keyword">\While</span>&#123; <span class="hljs-keyword">\&#123;</span>B<span class="hljs-keyword">\&#125;</span> is not empty &#125;&#123;    <span class="hljs-keyword">\eIf</span>&#123; <span class="hljs-keyword">\&#123;</span>B<span class="hljs-keyword">\&#125;</span> is even long &#125;&#123;      <span class="hljs-built_in">$</span>p <span class="hljs-keyword">\leftarrow</span><span class="hljs-built_in">$</span> B[middle - 1] or B[middle + 1]    &#125;&#123;      <span class="hljs-built_in">$</span>p <span class="hljs-keyword">\leftarrow</span><span class="hljs-built_in">$</span> B[middle]    &#125;    append B<span class="hljs-built_in">$</span><span class="hljs-built_in">_</span>p<span class="hljs-built_in">$</span> to the end of <span class="hljs-keyword">\&#123;</span>C<span class="hljs-keyword">\&#125;</span>  &#125;  <span class="hljs-keyword">\caption</span>&#123;A-B-C Sort Algorithm&#125;<span class="hljs-keyword">\end</span>&#123;algorithm&#125;<span class="hljs-keyword">\end</span>&#123;document&#125;</code></pre></div></details><h2 id="解答-3">解答</h2><p>上述算法两个步骤基本互逆，这使得我们<strong>只能调整相邻的元素</strong>。</p><p>模拟即可，但需要注意到 <span class="math inline">\([1, 2, 1]\rightarrow [1, 1, 2]\)</span>。</p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-type">int</span> n;  std::cin &gt;&gt; n;  <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i : a) &#123;    std::cin &gt;&gt; i;  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i -= <span class="hljs-number">2</span>) &#123;    <span class="hljs-keyword">if</span> (a[i] &gt; a[i + <span class="hljs-number">1</span>]) &#123;      std::<span class="hljs-built_in">swap</span>(a[i], a[i + <span class="hljs-number">1</span>]);    &#125;  &#125;  std::cout &lt;&lt; (std::<span class="hljs-built_in">is_sorted</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>()) ? <span class="hljs-string">&quot;yes\n&quot;</span> : <span class="hljs-string">&quot;no\n&quot;</span>);&#125;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcal O(n)\)</span></p></blockquote><p>Bonus: 赛时代码。</p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; b;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;  <span class="hljs-keyword">if</span> ((n - i) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp; a[i] &gt; a[i + <span class="hljs-number">1</span>]) &#123;    std::<span class="hljs-built_in">swap</span>(a[i], a[i + <span class="hljs-number">1</span>]);  &#125;  b.<span class="hljs-built_in">push_back</span>(a[i]);&#125;std::cout &lt;&lt; (std::<span class="hljs-built_in">is_sorted</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>()) ? <span class="hljs-string">&quot;YES\n&quot;</span> : <span class="hljs-string">&quot;NO\n&quot;</span>);</code></pre></div></details><h1 id="e.-breaking-the-wall">E. Breaking the Wall</h1><blockquote><p>本题 Hacked 数高达 <span class="math inline">\(1500^+\)</span>。</p></blockquote><h2 id="题意-4">题意</h2><p>给定一个数组 <spanclass="math inline">\(\{A\}\)</span>，你可多次选择单点 <spanclass="math inline">\(-2\)</span>，相邻元素（如果有）将会 <spanclass="math inline">\(-1\)</span>。</p><p>问至少需要打击多少次才会出现至少两个位置 <spanclass="math inline">\(&lt; 0\)</span> ？</p><h2 id="解答-4">解答</h2><p>枚举这俩可能的情况：</p><ul><li><p>两者相邻：<span class="math inline">\([1, 2, 1]\)</span> 或者<span class="math inline">\([1, 3, 3, 1]\)</span> 打击。</p></li><li><p>隔着一个：<span class="math inline">\([1, 2, 1]\)</span>打击。<span class="math inline">\(a, b\; (a \le b), a +\left\lceil\dfrac{b - a}{2}\right\rceil\)</span></p></li><li><p>离得很远：选择最小的两元素多次单点打击。</p></li></ul><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-type">int</span> n;  std::cin &gt;&gt; n;  <span class="hljs-keyword">auto</span> C = [&amp;](<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> d = <span class="hljs-number">2</span>) &#123;    <span class="hljs-built_in">return</span> (n + d - <span class="hljs-number">1</span>) / d;  &#125;;  <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;  <span class="hljs-type">int</span> m1 = INT_MAX, m2 = INT_MAX;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i : a) &#123;    std::cin &gt;&gt; i;    <span class="hljs-keyword">if</span> (i &lt; m1) &#123;      std::<span class="hljs-built_in">tie</span>(m1, m2) = std::tuple&#123;i, m1&#125;;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &lt; m2) &#123;      m2 = i;    &#125;  &#125;  <span class="hljs-type">int</span> ans = <span class="hljs-built_in">C</span>(m1) + <span class="hljs-built_in">C</span>(m2);  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;    <span class="hljs-type">int</span> A = a[i], B = a[i + <span class="hljs-number">1</span>];    ans = std::<span class="hljs-built_in">min</span>(ans, std::<span class="hljs-built_in">max</span>(&#123; <span class="hljs-built_in">C</span>(A), <span class="hljs-built_in">C</span>(B), <span class="hljs-built_in">C</span>(A + B, <span class="hljs-number">3</span>) &#125;));  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">2</span>; ++i) &#123;    <span class="hljs-type">int</span> A = a[i], B = a[i + <span class="hljs-number">2</span>];    <span class="hljs-keyword">if</span> (A &gt; B) &#123;      std::<span class="hljs-built_in">swap</span>(A, B);    &#125;    ans = std::<span class="hljs-built_in">min</span>(ans, A + <span class="hljs-built_in">C</span>(B - A, <span class="hljs-number">2</span>));  &#125;  std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ^ <span class="hljs-number">0</span>;&#125;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcal O(n)\)</span></p></blockquote><h1 id="f.-desktop-rearrangement">F. Desktop Rearrangement</h1><h2 id="题意-5">题意</h2><p>在二维矩阵上有一些 <span class="math inline">\(``\star&quot;\)</span>与 <span class="math inline">\(``\cdot&quot;\)</span>。</p><p>给出多组询问, 将 <span class="math inline">\((x, y)\)</span>格点的符号反转，即 <span class="math inline">\(``\star&quot;\leftrightarrow ``\cdot&quot;\)</span> 之后，回答将当前桌面上的 <spanclass="math inline">\(``\star&quot;\)</span>从左到右、从上到下排布整齐至少需要移动多少个 <spanclass="math inline">\(``\star&quot;\)</span> ？</p><p><strong>这个修改是永久的</strong>。</p><h2 id="解答-5">解答</h2><p>最小花费就是不在前 <strong>tot</strong> 个位置的星星个数。</p><p>对于每次修改，只会增加或者减少一个星星，因此每次回答都是 <spanclass="math inline">\(\mathcal O(1)\)</span> 的。</p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>)-&gt;<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);  <span class="hljs-type">int</span> n, m, q;  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;  <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">possessed</span><span class="hljs-params">(n * m)</span></span>;  <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>, o = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;      <span class="hljs-type">char</span> ch;      std::cin &gt;&gt; ch;      <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;        <span class="hljs-keyword">if</span> (possessed[cnt]) &#123;          o += <span class="hljs-number">1</span>;        &#125;        cnt += <span class="hljs-number">1</span>;        possessed[j * n + i] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (j * n + i &lt; cnt) &#123;          o += <span class="hljs-number">1</span>;        &#125;      &#125;    &#125;  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x, y; q != <span class="hljs-number">0</span>; --q) &#123;    std::cin &gt;&gt; x &gt;&gt; y;    <span class="hljs-type">int</span> i = -- y * n + -- x;    <span class="hljs-keyword">if</span> (possessed[i]) &#123;      <span class="hljs-keyword">if</span> (i &lt; cnt) &#123;        o -= <span class="hljs-number">1</span>;      &#125;      cnt -= <span class="hljs-number">1</span>;      possessed[i].<span class="hljs-built_in">flip</span>();      <span class="hljs-keyword">if</span> (possessed[cnt]) &#123;        o -= <span class="hljs-number">1</span>;      &#125;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">if</span> (possessed[cnt]) &#123;        o += <span class="hljs-number">1</span>;      &#125;      cnt += <span class="hljs-number">1</span>;      possessed[i].<span class="hljs-built_in">flip</span>();      <span class="hljs-keyword">if</span> (i &lt; cnt) &#123;        o += <span class="hljs-number">1</span>;      &#125;    &#125;    std::cout &lt;&lt; cnt - o &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ^ <span class="hljs-number">0</span>;&#125;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcal O(n \times m +q)\)</span></p></blockquote><h1 id="g.-remove-directed-edges">G. Remove Directed Edges</h1><h2 id="题意-6">题意</h2><p>给定一张 <span class="math inline">\(\rmDAG\)</span>，删去若干边，使得每个点：</p><ul><li>若原有出边，则至少删去一条。</li><li>若原有入边，则至少删去一条。</li></ul><p>随后选取子图 <spanclass="math inline">\(\{S\}\)</span>，其中的任两点之间可达（单方面到达即可）。求<span class="math inline">\(\left|S\right|\)</span> 最大是多少。</p><h2 id="解答-6">解答</h2><p>删哪些边？那些入、出度为 <span class="math inline">\(1\)</span>的点必须删除, 所以入、出度同时为 <span class="math inline">\(1\)</span>的点一定不会成为答案。</p><p>剩下的点，即使不与最终的 <span class="math inline">\(\{S\}\)</span>联通也无关紧要, 因为最后需要求解的子图也是 <spanclass="math inline">\(\rm DAG\)</span>，其最长链即为所求, <spanclass="math inline">\(dp\)</span> 会解决掉这些情况。</p><p><span class="math inline">\(dp\)</span> 的过程实际上就是遍历 <spanclass="math inline">\(DAG\)</span>, 使用拓扑排序的 Kahn 算法即可。</p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">200&#x27;007</span>;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; e[N];<span class="hljs-type">int</span> deg[N][<span class="hljs-number">2</span>];<span class="hljs-type">int</span> nd[N];<span class="hljs-type">int</span> dp[N];std::vector&lt;<span class="hljs-type">int</span>&gt; v[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>)-&gt;<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);  <span class="hljs-type">int</span> n, m;  std::cin &gt;&gt; n &gt;&gt; m;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;    <span class="hljs-keyword">auto</span> &amp;[x, y] = e[i];    std::cin &gt;&gt; x &gt;&gt; y;    ++ deg[x][<span class="hljs-number">0</span>], ++ deg[y][<span class="hljs-number">1</span>];  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;    <span class="hljs-keyword">auto</span> &amp;[x, y] = e[i];    <span class="hljs-keyword">if</span> (deg[x][<span class="hljs-number">0</span>] != <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> deg[y][<span class="hljs-number">1</span>] != <span class="hljs-number">1</span>) &#123;      v[x].<span class="hljs-built_in">push_back</span>(y);      ++ nd[y];    &#125;  &#125;  std::queue&lt;<span class="hljs-type">int</span>&gt; q;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;    <span class="hljs-keyword">if</span> (!nd[i]) &#123;      q.<span class="hljs-built_in">push</span>(i);      dp[i] = <span class="hljs-number">1</span>;    &#125;  &#125;  <span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>;  <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;    <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();    q.<span class="hljs-built_in">pop</span>();    ans = std::<span class="hljs-built_in">max</span>(ans, dp[t]);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;i : v[t]) &#123;      dp[i] = std::<span class="hljs-built_in">max</span>(dp[i], dp[t] + <span class="hljs-number">1</span>);      <span class="hljs-keyword">if</span> (-- nd[i] == <span class="hljs-number">0</span>) &#123;        q.<span class="hljs-built_in">push</span>(i);      &#125;    &#125;  &#125;  std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ^ <span class="hljs-number">0</span>;&#125;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcal O(n + m)\)</span></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>cf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kahn</tag>
      
      <tag>拓扑排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cf785</title>
    <link href="/cf/785/"/>
    <url>/cf/785/</url>
    
    <content type="html"><![CDATA[<p><ahref="https://codeforces.com/contest/1673">https://codeforces.com/contest/1673</a></p><blockquote><p>邓老师说，给自己看的题解要写的简练一些。这样回头看的时候也会轻松许多。</p></blockquote><h1 id="a.-subtle-substring-subtraction">A. Subtle SubstringSubtraction</h1><h2 id="题意">题意</h2><p>给定字符串 <span class="math inline">\(s\)</span>, 并定义字符串的<strong>权重</strong> 为其字符顺序之和。如<code>w("aba") = 1 + 2 + 1</code>。</p><p>博弈，先手可取走 <span class="math inline">\(s\)</span><strong>偶数长度</strong> 的子串，并获得其权重，而后者则可取走<strong>奇数长度</strong> 的。无法行动时分高者胜。问：</p><ol type="1"><li>谁胜？</li><li>两人获得的 <strong>权重差</strong> 最大为多少？</li></ol><h2 id="解答">解答</h2><p>如果 <span class="math inline">\(s\)</span>仅含一个字符，先手无法行动，于是后手胜。</p><p>偶数长度，先手胜，并获得全部字符串。</p><p>奇数长度，先手也可取得 <code>s[1:]</code> 或者<code>s[:-1]</code>，容易发现得分不会劣于后手，因而先手总胜。</p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;  std::string s;  std::cin &gt;&gt; s;  <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;ch : s) &#123;    ch -= <span class="hljs-string">&#x27;a&#x27;</span> - <span class="hljs-number">1</span>;    ans += ch;  &#125;  <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;    <span class="hljs-keyword">return</span> std::cout &lt;&lt; <span class="hljs-string">&quot;Bob &quot;</span> &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-built_in">void</span>();  &#125;  <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() &amp; <span class="hljs-number">1</span>) &#123;    ans -= <span class="hljs-number">2</span> * std::<span class="hljs-built_in">min</span>(s[<span class="hljs-number">0</span>], s.<span class="hljs-built_in">back</span>());  &#125;  std::cout &lt;&lt; <span class="hljs-string">&quot;Alice &quot;</span> &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcal O(n)\)</span></p></blockquote><h1 id="b.-a-perfectly-balanced-string">B. A Perfectly BalancedString?</h1><h2 id="题意-1">题意</h2><p>定义字符串 “平衡”，当且仅当其任意两字符 <spanclass="math inline">\(a, b\)</span> 满足在任意子串中出现频数相差不大于<span class="math inline">\(1\)</span>。</p><p>判断给定的字符串是否 “平衡”。</p><h2 id="解答-1">解答</h2><blockquote><p>注意到 <span class="math inline">\(a \star a\)</span> 及不在 <spanclass="math inline">\(\star\)</span> 中的一个字符 <spanclass="math inline">\(x\)</span> 总是不满足条件的。如在 <spanclass="math inline">\(``abcak&quot;\)</span> 中选择三元组 <spanclass="math inline">\(\left \langle ``abca&quot;, ``a&quot;, ``k&quot;\right \rangle\)</span>。 如果不存在这样的情形，则一定“平衡”：组成该字符串的子串均 “平衡”，则该串也如此。 在 <spanclass="math inline">\(\mathcal O(\left|\Sigma\right| \times n)\)</span>检验这一点是容易的，但 ”平衡” 串具有一个优美的性质：</p></blockquote><p>其 <strong>必有循环节</strong> （注意 <spanclass="math inline">\(``aba&quot;\)</span> 也是循环的, 即存在 <spanclass="math inline">\(k\)</span> 使得 <span class="math inline">\(s[i +k] = s[i]\)</span>, 其中 <span class="math inline">\(i\)</span> 遍历<span class="math inline">\(1 \sim n - k\)</span>）。</p><hr /><p>证明：</p><p><span class="math inline">\(a \star a ?\)</span>：如果 <spanclass="math inline">\(? \not\in \star\)</span>，则不平衡。</p><p>反之 <span class="math inline">\(\star\)</span> 遍历所有非 <spanclass="math inline">\(a\)</span> 字符， 若 <spanclass="math inline">\(\star[1] \ne\; ?\)</span>，取 <spanclass="math inline">\(\left \langle ``\star[x:]?&quot;,``\star[0]&quot;, ``?&quot; \right \rangle, \mathtt{\;where\;} \star[x]= ?\)</span> 也不平衡。</p><p>因此必有 <span class="math inline">\(\star[0] =\; ?\)</span>。</p><hr /><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;  std::string s;  std::cin &gt;&gt; s;  <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>(), len = s.<span class="hljs-built_in">size</span>();  <span class="hljs-type">static</span> <span class="hljs-type">char</span> * str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span> [<span class="hljs-number">200007</span>];  std::<span class="hljs-built_in">strcpy</span>(str + <span class="hljs-number">1</span>, s.<span class="hljs-built_in">data</span>());  std::array&lt;<span class="hljs-type">int</span>, 26&gt; pos&#123;&#125;;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;    <span class="hljs-type">int</span> si = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;    <span class="hljs-keyword">if</span> (pos[si] != <span class="hljs-number">0</span>) &#123;      len = i - pos[si];      <span class="hljs-keyword">break</span>;    &#125;    pos[si] = i;  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + len &lt;= n; ++i) &#123;    <span class="hljs-keyword">if</span> (str[i] != str[i + len]) &#123;      <span class="hljs-keyword">return</span> std::cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>, <span class="hljs-built_in">void</span>();    &#125;  &#125;  std::cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;&#125;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcal O(n)\)</span></p></blockquote><h1 id="c.-palindrome-basis">C. Palindrome Basis</h1><h2 id="题意-2">题意</h2><p>整数划分问题，限制其中每个数都是回文的。</p><ul><li><span class="math inline">\(n \le 4 \times 10 ^ 4\)</span></li></ul><h2 id="解答-2">解答</h2><p>处理出所有的回文数，随后进行整数划分（完全背包计数 / <ahref="https://studyingfather.com/archives/3000">五边形数</a>）。</p><blockquote><p>表白 <code>SF</code>, /qq /xin</p></blockquote><style>.rated-user {  font-family: helvetica neue, Helvetica, Arial, sans-serif;  text-decoration: none !important;  font-weight: 700;  display: inline-block;}.user-legendary {  color: red !important;}.user-legendary::first-letter {  color: #000 !important;}</style><blockquote><p>注：其中 <code>Z</code> 为 <ahref="https://codeforces.com/profile/jiangly"><font class="rated-user user-legendary">jiangly</font></a>的整数模板类。</p></blockquote><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-type">static</span> <span class="hljs-type">bool</span> initialized = <span class="hljs-literal">false</span>;  <span class="hljs-type">static</span> std::vector&lt;<span class="hljs-type">int</span>&gt; palind;  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">4E4</span> + <span class="hljs-number">7</span>;  <span class="hljs-comment">// static std::array&lt;Z, N&gt; dp&#123;&#125;; -&gt; 寄！</span>  <span class="hljs-type">static</span> Z dp[N];  <span class="hljs-keyword">if</span> (!initialized) &#123;    initialized ^= <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N - <span class="hljs-number">7</span>; ++i) &#123;      <span class="hljs-keyword">auto</span> s = std::<span class="hljs-built_in">to_string</span>(i);      <span class="hljs-keyword">if</span> (s == std::<span class="hljs-built_in">string</span>(s.<span class="hljs-built_in">rbegin</span>(), s.<span class="hljs-built_in">rend</span>())) &#123;        palind.<span class="hljs-built_in">push_back</span>(i);      &#125;    &#125;    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;num : palind) &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + num &lt;= N - <span class="hljs-number">7</span>; ++i) &#123;        dp[i + num] += dp[i];      &#125;    &#125;  &#125;  <span class="hljs-type">int</span> n;  std::cin &gt;&gt; n;  std::cout &lt;&lt; dp[n] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(O(n \times p), p\)</span>为回文数个数，非常小。</p></blockquote><h1 id="d.-lost-arithmetic-progression">D. Lost ArithmeticProgression</h1><h2 id="题意-3">题意</h2><p>有两个 <span class="math inline">\(A.P. \{A\}, \{B\}\)</span>，给出<span class="math inline">\(\{B\}\)</span> 以及 <spanclass="math inline">\(\{A\} \bigcap \{B\}\)</span>，问 <spanclass="math inline">\(\{A\}\)</span> 有多少种可能。</p><p>或回答有无穷多个。</p><h2 id="解答-3">解答</h2><p>首先如果 <span class="math inline">\(B_0 \gt C_0\)</span> 或者 <spanclass="math inline">\(B_{-1} \lt C_{-1}\)</span> 是不可以的，此时 <spanclass="math inline">\(\{C\}\)</span> 不合法。</p><p>在此基础上，如果 <span class="math inline">\(d_B \nmid C_0 -B_0\)</span> 也不行（即 <span class="math inline">\(\{B\} \bigcap \{C\}= \varnothing\)</span>）。</p><hr /><p>设 <span class="math inline">\(\{A\} = a + c \times \Z, \{B\} = b + d\times \Z\)</span>, 如何求其交？下面是一个例子：</p><p><span class="math display">\[\begin{cases}N = 5 n + 3 \\N = 7 n - 2\end{cases} \Rightarrow\begin{cases}N \equiv 3 \pmod 5 \\N \equiv 5 \pmod 7\end{cases} \Rightarrow_{\gcd(5, 7) = 1}N \equiv 33 \pmod {35}\]</span></p><p>注意到第二部分有唯一解当且仅当 <span class="math inline">\(\gcd(c, d)\mid \small | a - b \small |\)</span> (裴蜀定理)。</p><p>由中国剩余定理（或拓欧）可得，<spanclass="math inline">\(\dfrac{cd}{\gcd(c, d)} = \mathrm{lcm}(c,d)\)</span> 为解的模数，即公差。</p><p>于是我们找到了另一组不合法的情况：<span class="math inline">\(d_B\nmid d_C\)</span>。</p><hr /><p>如果 <span class="math inline">\(\{C\}\)</span> 的首项的前一项 <spanclass="math inline">\(C_0 - d_C \lt B_0\)</span>，或者最后一项 <spanclass="math inline">\(C_{-1} + d_C \gt B_{-1}\)</span> 时，<spanclass="math inline">\(\{A\}\)</span> 可以无限左右拓展。</p><p>否则有限组解，给定了 <span class="math inline">\(\{A\} \bigcap\{B\}\)</span>，于是从倍数转换成了约数。</p><p>对于 <span class="math inline">\(d_C\)</span>的约数，方案左右独立，根据乘法原理计算：</p><p><span class="math display">\[\sum_{\mathrm{lcm}(p, d_B) = d_C}\left( \dfrac{d_C}{p}\right)^2\]</span></p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;  i64 b, q, y, c, r, z;  std::cin &gt;&gt; b &gt;&gt; q &gt;&gt; y &gt;&gt; c &gt;&gt; r &gt;&gt; z;  i64 lb = c + (z - <span class="hljs-number">1</span>) * r, lc = b + (y - <span class="hljs-number">1</span>) * q;  <span class="hljs-keyword">if</span> (r % q || (c - b) % q || c &lt; b || lb &gt; lc) &#123;    <span class="hljs-keyword">return</span> std::cout &lt;&lt; <span class="hljs-string">&quot;0\n&quot;</span>, <span class="hljs-built_in">void</span>();  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c - r &lt; b || lb + r &gt; lc) &#123;    <span class="hljs-keyword">return</span> std::cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>, <span class="hljs-built_in">void</span>();  &#125;  Z ans = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (i64 i = <span class="hljs-number">1</span>; i * i &lt;= r; ++i) &#123;    <span class="hljs-keyword">if</span> (r % i == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">lcm</span>(i, q) == r) &#123;        ans += r / i * r / i;      &#125;      <span class="hljs-keyword">if</span> (i * i != r) &#123;        i64 t = r / i;        <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">lcm</span>(t, q) == r) &#123;          ans += r / t * r / t;        &#125;      &#125;    &#125;  &#125;  std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(\mathcal O(\sqrt n \lgn)\)</span></p></blockquote><h1 id="e.-power-or-xor">* E. Power or XOR?</h1><h2 id="题意-4">题意</h2><p>&lt;++&gt;</p><h2 id="解答-4">解答</h2><p>&lt;++&gt;</p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">using</span> LL = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1&#x27;000&#x27;000&#x27;007</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> y)</span> </span>&#123;  <span class="hljs-keyword">if</span> ((x += y) &gt;= mod) &#123;    x -= mod;  &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);  cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);  <span class="hljs-type">int</span> n, k;  cin &gt;&gt; n &gt;&gt; k;  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">B</span><span class="hljs-params">(n)</span></span>;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> &amp;Bi : B) &#123;    cin &gt;&gt; Bi;  &#125;  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>)</span></span>;  map&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, <span class="hljs-type">int</span>&gt; F;  <span class="hljs-keyword">auto</span> f = [&amp;](<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;    <span class="hljs-keyword">if</span> (F.<span class="hljs-built_in">count</span>(&#123;n, k&#125;)) &#123;      <span class="hljs-keyword">return</span> F[&#123;n, k&#125;];    &#125;    <span class="hljs-type">int</span> &amp;res = F[&#123;n, k&#125;];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k; i &lt;= n; i += <span class="hljs-number">1</span>) &#123;      res ^= (n &amp; i) == i;    &#125;    <span class="hljs-keyword">return</span> res;  &#125;;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += <span class="hljs-number">1</span>)    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; i + <span class="hljs-number">20</span> <span class="hljs-keyword">and</span> j &lt; n; j += <span class="hljs-number">1</span>) &#123;      LL x = <span class="hljs-number">0</span>;      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i + <span class="hljs-number">1</span>; k &lt;= j; k += <span class="hljs-number">1</span>) &#123;        x += B[k];      &#125;      <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">20</span>) &#123;        <span class="hljs-keyword">break</span>;      &#125;      x = <span class="hljs-number">1</span> &lt;&lt; x;      x *= B[i];      <span class="hljs-keyword">if</span> (x &gt;= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>)) &#123;        <span class="hljs-keyword">break</span>;      &#125;      <span class="hljs-type">int</span> s = (i != <span class="hljs-number">0</span>) + (j + <span class="hljs-number">1</span> != n);      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">f</span>(n - <span class="hljs-number">1</span> - (j - i) - s, k - s)) &#123;        ans[x] ^= <span class="hljs-number">1</span>;      &#125;    &#125;  <span class="hljs-type">int</span> one = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -= <span class="hljs-number">1</span>) &#123;    <span class="hljs-keyword">if</span> (ans[i]) &#123;      one = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">if</span> (one) &#123;      cout &lt;&lt; ans[i];    &#125;  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> one) &#123;    cout &lt;&lt; <span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(&lt;++&gt;\)</span></p></blockquote><h1 id="f.-anti-theft-road-planning">* F. Anti-Theft Road Planning</h1><h2 id="题意-5">题意</h2><p>&lt;++&gt;</p><h2 id="解答-5">解答</h2><p>&lt;++&gt;</p><details><summary>展开代码</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">int</span> G[<span class="hljs-number">32</span>];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">key</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;  <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;  x = G[x];  y = G[y];  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;    t |= ((x &gt;&gt; i &amp; <span class="hljs-number">1</span>) &lt;&lt; (<span class="hljs-number">2</span> * i)) | ((y &gt;&gt; i &amp; <span class="hljs-number">1</span>) &lt;&lt; (<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>));  &#125;  <span class="hljs-keyword">return</span> t;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  G[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">2</span>; k &lt;= <span class="hljs-number">32</span>; k &lt;&lt;= <span class="hljs-number">1</span>) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k / <span class="hljs-number">2</span>; i++) &#123;      G[k - i - <span class="hljs-number">1</span>] = (k / <span class="hljs-number">2</span>) | G[i];    &#125;  &#125;  <span class="hljs-type">int</span> n, k;  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, <span class="hljs-built_in">key</span>(i, j - <span class="hljs-number">1</span>) ^ <span class="hljs-built_in">key</span>(i, j));    &#125;    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, <span class="hljs-built_in">key</span>(i - <span class="hljs-number">1</span>, j) ^ <span class="hljs-built_in">key</span>(i, j));    &#125;    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);  &#125;  <span class="hljs-built_in">fflush</span>(stdout);  <span class="hljs-type">int</span> x = <span class="hljs-built_in">key</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);  <span class="hljs-keyword">while</span> (k--) &#123;    <span class="hljs-type">int</span> v;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;v);    x ^= v;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">key</span>(i, j) == x) &#123;          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>);        &#125;      &#125;    &#125;    <span class="hljs-built_in">fflush</span>(stdout);  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div></details><blockquote><p>复杂度： <span class="math inline">\(&lt;++&gt;\)</span></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>cf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>todo</tag>
      
      <tag>循环节</tag>
      
      <tag>五边形数</tag>
      
      <tag>背包计数</tag>
      
      <tag>数论</tag>
      
      <tag>crt</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>source-code-test</title>
    <link href="/blog/source-code-test/"/>
    <url>/blog/source-code-test/</url>
    
    <content type="html"><![CDATA[<p>This is the source code of <ahref="https://algo.teko7a.top/blog/test-md-format/">last testpost</a></p><div class="hljs code-wrapper"><pre><code class="hljs md">---title: test-md-formatpermalink: /blog/test-md-format/categories: testtags: testtoc: truemath: truedate: 2022-05-01 22:18:19<span class="hljs-section">updated: 2022-05-02 00:00:34</span><span class="hljs-section">---</span><span class="hljs-section"># formula</span>&#123;% note info %&#125;This is a test for $\LaTeX$ and other formats.&#123;% endnote %&#125;$$f(x) = x ^ 2$$$$\mathrm&#123;ABCDEabcde1234&#125;\\\mathit&#123;ABCDEabcde1234&#125;\\\mathbf&#123;ABCDEabcde1234&#125;\\\mathsf&#123;ABCDEabcde1234&#125;\\\mathtt&#123;ABCDEabcde1234&#125;\\\mathcal&#123;ABCDEFGHIJK&#125;\\\mathscr&#123;ABCDEFGHIJK&#125;\\\mathfrak&#123;ABCDEFGHIJK&#125;\\\mathbb&#123;ABCDEFGHIJK&#125;\\$$$$\large P = \frac&#123;\displaystyle&#123;\sum<span class="hljs-emphasis">_&#123;i=1&#125;^n (x_</span>i- x)(y<span class="hljs-emphasis">_i- y)&#125;&#125;</span><span class="hljs-emphasis">&#123;\displaystyle&#123;\left[</span><span class="hljs-emphasis">\sum_</span>&#123;i=1&#125;^n(x<span class="hljs-emphasis">_i-x)^2</span><span class="hljs-emphasis">\sum_</span>&#123;i=1&#125;^n(y<span class="hljs-emphasis">_i- y)^2</span><span class="hljs-emphasis">\right]^&#123;1/2&#125;&#125;&#125;\\</span><span class="hljs-emphasis">$$</span><span class="hljs-emphasis"></span><span class="hljs-emphasis">$$</span><span class="hljs-emphasis">\color&#123;black&#125;&#123;黑色&#125;,\color&#123;red&#125;&#123;红色&#125;,\color&#123;green&#125;&#123;绿色&#125;,\color&#123;brown&#125;&#123;棕色&#125;,\color&#123;pink&#125;&#123;粉色&#125;\\</span><span class="hljs-emphasis">\color&#123;white&#125;&#123;白色&#125;,\color&#123;blue&#125;&#123;蓝色&#125;,\color&#123;red&#125;&#123;红色&#125;,\color&#123;yellow&#125;&#123;黄色&#125;,\color&#123;gray&#125;&#123;灰色&#125;\\</span><span class="hljs-emphasis">\color&#123;orange&#125;&#123;橘色&#125;,\color&#123;teal&#125;&#123;靛青&#125;,\color&#123;darkgray&#125;&#123;深灰&#125;,\color&#123;olive&#125;&#123;橄榄&#125;,\color&#123;violet&#125;&#123;紫罗兰&#125;\\</span><span class="hljs-emphasis">\color&#123;lime&#125;&#123;青柠&#125;,\color&#123;lightgray&#125;&#123;淡灰&#125;,\color&#123;cyan&#125;&#123;青色&#125;,\color&#123;magenta&#125;&#123;品红&#125;,\color&#123;purple&#125;&#123;紫色&#125;</span><span class="hljs-emphasis">,\color&#123;silver&#125;&#123;银色&#125;</span><span class="hljs-emphasis">$$</span><span class="hljs-emphasis"></span><span class="hljs-emphasis">&gt; 颜色测试失败</span><span class="hljs-emphasis"></span><span class="hljs-emphasis">$$</span><span class="hljs-emphasis">\large \underset&#123;j=1&#125;&#123;\overset&#123;\infty&#125;&#123;\LARGE \mathrm K&#125;&#125;\frac&#123;a_</span>j&#125;&#123;b<span class="hljs-emphasis">_j&#125;</span><span class="hljs-emphasis">=\cfrac&#123;a_</span>1&#125;&#123;b<span class="hljs-emphasis">_1</span><span class="hljs-emphasis">+\cfrac&#123;a_</span>2&#125;&#123;b<span class="hljs-emphasis">_2</span><span class="hljs-emphasis">+\cfrac&#123;a_</span>3&#125;&#123;b<span class="hljs-emphasis">_3</span><span class="hljs-emphasis">+\cfrac&#123;a_</span>4&#125;&#123;b<span class="hljs-emphasis">_4</span><span class="hljs-emphasis">+\ddots&#125;&#125;&#125;&#125;\\</span><span class="hljs-emphasis">$$</span><span class="hljs-emphasis"></span><span class="hljs-emphasis">$$</span><span class="hljs-emphasis">\large</span><span class="hljs-emphasis">\cfrac&#123;a_</span>&#123;1&#125;&#125;&#123;b<span class="hljs-emphasis">_&#123;1&#125;+\cfrac&#123;a_</span>&#123;2&#125;&#125;&#123;b<span class="hljs-emphasis">_&#123;2&#125;+\cfrac&#123;a_</span>&#123;3&#125;&#125;&#123;b<span class="hljs-emphasis">_&#123;3&#125;+\ddots &#125;&#125;&#125;</span><span class="hljs-emphasis">=&#123;\genfrac&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;a_</span>1&#125;&#123;b<span class="hljs-emphasis">_1&#125;&#125;  </span><span class="hljs-emphasis">&#123;\genfrac&#123;&#125;&#123;&#125;&#123;0pt&#125;&#123;&#125;&#123;&#125;&#123;+&#125;&#125;   </span><span class="hljs-emphasis">&#123;\genfrac&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;a_</span>2&#125;&#123;b<span class="hljs-emphasis">_2&#125;&#125;   </span><span class="hljs-emphasis">&#123;\genfrac&#123;&#125;&#123;&#125;&#123;0pt&#125;&#123;&#125;&#123;&#125;&#123;+&#125;&#125;   </span><span class="hljs-emphasis">&#123;\genfrac&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;a_</span>3&#125;&#123;b<span class="hljs-emphasis">_3&#125;&#125;   </span><span class="hljs-emphasis">&#123;\genfrac&#123;&#125;&#123;&#125;&#123;0pt&#125;&#123;&#125;&#123;&#125;&#123;+\dots&#125;&#125;\\</span><span class="hljs-emphasis">$$</span><span class="hljs-emphasis"></span><span class="hljs-emphasis"># tags</span><span class="hljs-emphasis"></span><span class="hljs-emphasis"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-primary&quot;</span>&gt;</span></span> primary     <span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><span class="hljs-emphasis"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-secondary&quot;</span>&gt;</span></span> secondary <span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><span class="hljs-emphasis"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-success&quot;</span>&gt;</span></span> success     <span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><span class="hljs-emphasis"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-danger&quot;</span>&gt;</span></span> danger       <span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><span class="hljs-emphasis"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-warning&quot;</span>&gt;</span></span> warning     <span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><span class="hljs-emphasis"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-info&quot;</span>&gt;</span></span> info           <span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><span class="hljs-emphasis"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-light&quot;</span>&gt;</span></span> light         <span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><span class="hljs-emphasis"></span><span class="hljs-emphasis">```html</span><span class="hljs-emphasis"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-primary&quot;</span>&gt;</span></span> primary     <span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><span class="hljs-emphasis"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-secondary&quot;</span>&gt;</span></span> secondary <span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><span class="hljs-emphasis"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-success&quot;</span>&gt;</span></span> success     <span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><span class="hljs-emphasis"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-danger&quot;</span>&gt;</span></span> danger       <span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><span class="hljs-emphasis"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-warning&quot;</span>&gt;</span></span> warning     <span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><span class="hljs-emphasis"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-info&quot;</span>&gt;</span></span> info           <span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><span class="hljs-emphasis"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-light&quot;</span>&gt;</span></span> light         <span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><span class="hljs-emphasis">```</span><span class="hljs-emphasis"></span><span class="hljs-emphasis"># code</span><span class="hljs-emphasis">```go</span><span class="hljs-emphasis">package main</span><span class="hljs-emphasis"></span><span class="hljs-emphasis">import &quot;fmt&quot;</span><span class="hljs-emphasis"></span><span class="hljs-emphasis">func main() &#123;</span><span class="hljs-emphasis">    ch := make(chan float64)</span><span class="hljs-emphasis">    ch &lt;- 1.0e10    // magic number</span><span class="hljs-emphasis">    x, ok := &lt;- ch</span><span class="hljs-emphasis">    defer fmt.Println(`exitting now\`)</span><span class="hljs-emphasis">    go println(len(&quot;hello world!&quot;))</span><span class="hljs-emphasis">    return</span><span class="hljs-emphasis">&#125;</span><span class="hljs-emphasis">```</span><span class="hljs-emphasis"></span><span class="hljs-emphasis"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">details</span>&gt;</span></span></span><span class="hljs-emphasis"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">summary</span>&gt;</span></span> C++ —— The best language! <span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">summary</span>&gt;</span></span></span><span class="hljs-emphasis"></span><span class="hljs-emphasis">```cpp</span><span class="hljs-emphasis">#include <span class="language-xml">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-emphasis"></span><span class="hljs-emphasis">using i64 = long long; // &lt;+&gt;</span><span class="hljs-emphasis"></span><span class="hljs-emphasis">void solve() &#123;</span><span class="hljs-emphasis">  int n;</span><span class="hljs-emphasis">  std::cin &gt;&gt; n;</span><span class="hljs-emphasis">  for (int i = n; i &gt; 0; --i) &#123;</span><span class="hljs-emphasis">    std::cout &lt;&lt; i &lt;&lt; &quot; \n&quot;[i == 1];</span><span class="hljs-emphasis">  &#125;</span><span class="hljs-emphasis">&#125;</span><span class="hljs-emphasis"></span><span class="hljs-emphasis">int main() &#123;</span><span class="hljs-emphasis">  std::cin.tie(nullptr)-&gt;sync_</span>with<span class="hljs-emphasis">_stdio(false);</span><span class="hljs-emphasis"></span><span class="hljs-emphasis">  int tt = 1;</span><span class="hljs-emphasis">  std::cin &gt;&gt; tt;</span><span class="hljs-emphasis">  while (tt --) &#123;</span><span class="hljs-emphasis">    solve();</span><span class="hljs-emphasis">  &#125;</span><span class="hljs-emphasis"></span><span class="hljs-emphasis">  return 0 ^ 0;</span><span class="hljs-emphasis">&#125;</span><span class="hljs-emphasis">```</span><span class="hljs-emphasis"><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">details</span>&gt;</span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test-md-format</title>
    <link href="/blog/test-md-format/"/>
    <url>/blog/test-md-format/</url>
    
    <content type="html"><![CDATA[<h1 id="formula">formula</h1><div class="note note-info">            <p>This is a test for <span class="math inline">\(\LaTeX\)</span> andother formats.</p>          </div><p><span class="math display">\[f(x) = x ^ 2\]</span></p><p><span class="math display">\[\mathrm{ABCDEabcde1234}\\\mathit{ABCDEabcde1234}\\\mathbf{ABCDEabcde1234}\\\mathsf{ABCDEabcde1234}\\\mathtt{ABCDEabcde1234}\\\mathcal{ABCDEFGHIJK}\\\mathscr{ABCDEFGHIJK}\\\mathfrak{ABCDEFGHIJK}\\\mathbb{ABCDEFGHIJK}\\\]</span></p><p><span class="math display">\[\large P = \frac{\displaystyle{\sum_{i=1}^n (x_i- x)(y_i- y)}}{\displaystyle{\left[\sum_{i=1}^n(x_i-x)^2\sum_{i=1}^n(y_i- y)^2\right]^{1/2}}}\\\]</span></p><p><span class="math display">\[\color{black}{黑色},\color{red}{红色},\color{green}{绿色},\color{brown}{棕色},\color{pink}{粉色}\\\color{white}{白色},\color{blue}{蓝色},\color{red}{红色},\color{yellow}{黄色},\color{gray}{灰色}\\\color{orange}{橘色},\color{teal}{靛青},\color{darkgray}{深灰},\color{olive}{橄榄},\color{violet}{紫罗兰}\\\color{lime}{青柠},\color{lightgray}{淡灰},\color{cyan}{青色},\color{magenta}{品红},\color{purple}{紫色},\color{silver}{银色}\]</span></p><blockquote><p>颜色测试失败</p></blockquote><p><span class="math display">\[\large \underset{j=1}{\overset{\infty}{\LARGE \mathrm K}}\frac{a_j}{b_j}=\cfrac{a_1}{b_1+\cfrac{a_2}{b_2+\cfrac{a_3}{b_3+\cfrac{a_4}{b_4+\ddots}}}}\\\]</span></p><p><span class="math display">\[\large\cfrac{a_{1}}{b_{1}+\cfrac{a_{2}}{b_{2}+\cfrac{a_{3}}{b_{3}+\ddots }}}={\genfrac{}{}{}{}{a_1}{b_1}}  {\genfrac{}{}{0pt}{}{}{+}}   {\genfrac{}{}{}{}{a_2}{b_2}}   {\genfrac{}{}{0pt}{}{}{+}}   {\genfrac{}{}{}{}{a_3}{b_3}}   {\genfrac{}{}{0pt}{}{}{+\dots}}\\\]</span></p><h1 id="tags">tags</h1><p class="note note-primary">primary</p><p class="note note-secondary">secondary</p><p class="note note-success">success</p><p class="note note-danger">danger</p><p class="note note-warning">warning</p><p class="note note-info">info</p><p class="note note-light">light</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-primary&quot;</span>&gt;</span> primary     <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-secondary&quot;</span>&gt;</span> secondary <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-success&quot;</span>&gt;</span> success     <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-danger&quot;</span>&gt;</span> danger       <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-warning&quot;</span>&gt;</span> warning     <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-info&quot;</span>&gt;</span> info           <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-light&quot;</span>&gt;</span> light         <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre></div><h1 id="code">code</h1><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">float64</span>)    ch &lt;- <span class="hljs-number">1.0e10</span>    <span class="hljs-comment">// magic number</span>    x, ok := &lt;- ch    <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">`exitting now\`</span>)    <span class="hljs-keyword">go</span> <span class="hljs-built_in">println</span>(<span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;hello world!&quot;</span>))    <span class="hljs-keyword">return</span>&#125;</code></pre></div><details><summary>C++ —— The best language!</summary><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>; <span class="hljs-comment">// &lt;+&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-type">int</span> n;  std::cin &gt;&gt; n;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt; <span class="hljs-number">0</span>; --i) &#123;    std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == <span class="hljs-number">1</span>];  &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>)-&gt;<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);  <span class="hljs-type">int</span> tt = <span class="hljs-number">1</span>;  std::cin &gt;&gt; tt;  <span class="hljs-keyword">while</span> (tt --) &#123;    <span class="hljs-built_in">solve</span>();  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ^ <span class="hljs-number">0</span>;&#125;</code></pre></div></details>]]></content>
    
    
    <categories>
      
      <category>test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cf773</title>
    <link href="/cf/773/"/>
    <url>/cf/773/</url>
    
    <content type="html"><![CDATA[<p class="note note-warning">This is an empty post since a mistake</p><p>&lt;++&gt;</p>]]></content>
    
    
    <categories>
      
      <category>cf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>todo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
